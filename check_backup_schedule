#!/bin/bash
#
# checks if latest backup was already according to schedule
# returns 0 if backup needed, 1 if not needed, and -1 on error
# used by pm to run at thaw/resume

install_dir=$(dirname `realpath $0`)

for i; do # loop over cmdline args
    if [ "$i" == "test" ]; then
	test=1
    elif [ "X$i" == "X-v" ]; then
	debug=1
    fi
done

conf=$install_dir/config
echo "Using config from $conf"
. $conf

if [ ! -w $log_dir ]; then
    echo "$log_dir not ours or does not exist"
    [[ $test ]] || exit -1
fi
echo "Using logfiles from $log_dir"

# find sbackup schedule from crontab (for user, if available) 
# else use /etc/cron* (root)
interval=`crontab -l | $install_dir/decode_crontab`
if [ "$interval" != "" ]; then
    echo "Using interval $interval from $USER crontab"
else
    # no interval set from crontab, search /etc/cron.*:
    for sbackup in /etc/cron.*/sbackup; do
	if [ -x "$sbackup" ]; then 
	    interval="${sbackup%/sbackup}"
	    interval="${interval#/etc/cron.}"
	    echo "Using interval $interval from /etc/cron.*"
	    [[ $debug ]] && echo $sbackup $interval
	fi
    done
fi
if [ "$interval" == "" ]; then
    interval=`awk '\
        /^\[/{p=0} \
	/^\[\W*schedule\W*\]/{p=1}\
	p&&/^anacron\W*=\W*/{\
	gsub("^anacron\\\W*=\\\W*","");\
	gsub("^[^/]*//","");\
	gsub("/.*$","");\
	print}' $conf`
    echo "Using interval $interval from $conf"
fi

if   [ "$interval" == "hourly"  ]; then
    [[ $debug ]] && echo Hourly
    now=`date +%Y-%m-%d_%H`
elif [ "$interval" == "daily"   ]; then
    [[ $debug ]] && echo Daily
    now=`date +%Y-%m-%d`
elif [ "$interval" == "monthly" ]; then
    [[ $debug ]] && echo Monthly
    now=`date +%Y-%m`
else
    [[ $debug ]] && echo Assume Yearly:
    now=`date +%Y`
fi

[[ $debug ]] && echo "$interval $now"

# get previous backups:
if [ ! -d $log_dir ]; then
    echo "E: no sbackup logdir $log_dir"
    [[ $test ]] || exit -1
fi

backups=`ls -t1 $log_dir/sbackup.$now*.log $log_dir/sbackup.log*`
[[ $debug ]] && echo "Checking logfiles:"
[[ $debug ]] && ls $backups
for backup in $backups; do 
    type=${backup##*.}
    if [ "$type" == "gz" ]; then
	cat="gunzip -c"
    else
	cat="cat"
    fi
    success=`$cat $backup | grep -c '^'$now'[ 0-9:,-]*INFO: TAR .*has been finished successfully.'`
    if [ $success -eq 0 ]; then
	success=`$cat $backup | grep -c '^'$now'[ 0-9:,-]*INFO: TAR .*returned warnings'`
    fi
    error=`$cat $backup | grep -c '^'$now'[ 0-9:,-]*ERROR:'`
    echo "$backup $success $error"
    if [ $success -ne 0 ] && [ $error -eq 0 ]; then
	# found at least one succesful backup in interval
	echo "$interval backup succesful on $now according to ${backup##*/}"
	
	# We're done now, no backup needed; exit cleanly
	[[ $debug ]] && echo Succesful $interval backup $backup
	exit 0
    fi
done

# backup needed
echo "No succesful $interval backup for $now"

# find backup hostname and see if we can ssh onto it
# (to avoid harrassing the user with useless popups)
if [ "X$target_host" == "X" ] ; then
    echo "Local backup"
else
    if ( ! ssh -o BatchMode=yes $target_host hostname < /dev/null ); then 
	echo Cannot connect to $target_host
	exit -1
    fi
fi

# check if target dir exists:
if [ -d "$target_dir" ]; then
    echo "Backup target present:"
    ls -ld "$target_dir"
else
    echo "Target '$target_dir' still not present."
    echo "Will continue, but don't hold your breath..."
fi

exit 1

#last line
